package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/imports"
)

func main() {
	log.SetPrefix("accessor: ")

	var typeName, output string
	var setter bool
	flag.StringVar(&typeName, "type", "", "type name") // TODO: list of type
	flag.StringVar(&output, "output", "", "output file name. default: srcdir/{type}_accessor.go")
	flag.BoolVar(&setter, "setter", false, "generate setter")
	flag.Parse()

	if typeName == "" {
		flag.Usage()
		os.Exit(2)
	}

	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}

	gen := generator{
		cmdArgs:    os.Args[1:],
		withSetter: setter,
	}
	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
		gen.parsePackageDir(args[0])
	} else {
		dir = filepath.Dir(args[0])
		gen.parsePackageFiles(args)
	}

	if output == "" {
		output = filepath.Join(dir, strings.ToLower(fmt.Sprintf("%s_accessor.go", typeName)))
	}

	data, err := imports.Process(output, gen.generate(typeName), nil)
	if err != nil {
		log.Fatalf("go import failed: %s", err)
	}

	if err := ioutil.WriteFile(output, data, 0644); err != nil {
		log.Fatalf("write file(%s) failed: %s", output, err)
	}
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatalf("os stat failed:%s", err)
	}
	return info.IsDir()
}

type generator struct {
	cmdArgs    []string
	withSetter bool
	buf        bytes.Buffer
	pkg        *pkg
}

func (g *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

type file struct {
	pkg  *pkg
	file *ast.File
}

type pkg struct {
	dir   string
	name  string
	files []*file
}

func (g *generator) parsePackageDir(dir string) {
	pkg, err := build.Default.ImportDir(dir, 0)
	if err != nil {
		log.Fatalf("import dir(%s) failed:%s", dir, err)
	}

	var names []string
	names = append(names, pkg.GoFiles...)
	names = append(names, pkg.CgoFiles...)

	g.parsePackage(dir, makePath(dir, names))
}

func (g *generator) parsePackageFiles(names []string) {
	g.parsePackage(".", names)
}

func makePath(dir string, names []string) []string {
	if dir == "." {
		return names
	}
	ret := make([]string, len(names))
	for i, name := range names {
		ret[i] = filepath.Join(dir, name)
	}
	return ret
}

func (g *generator) parsePackage(dir string, names []string) {
	var files []*file
	var astFiles []*ast.File
	g.pkg = new(pkg)
	fs := token.NewFileSet()
	for _, name := range names {
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fs, name, nil, parser.ParseComments)
		if err != nil {
			log.Fatalf("parse package %s failed: %s", name, err)
		}
		astFiles = append(astFiles, parsedFile)
		files = append(files, &file{
			file: parsedFile,
			pkg:  g.pkg,
		})
	}
	if len(astFiles) == 0 {
		log.Fatalf("no buildable go files:%s", dir)
	}
	g.pkg.name = astFiles[0].Name.Name
	g.pkg.files = files
	g.pkg.dir = dir
}

func (g *generator) generate(typeName string) []byte {
	var stype *ast.StructType
	for _, file := range g.pkg.files {
		if file.file == nil {
			continue
		}

		ast.Inspect(file.file, func(node ast.Node) bool {
			decl, ok := node.(*ast.GenDecl)
			if !ok || decl.Tok != token.TYPE {
				return true
			}
			for _, spec := range decl.Specs {
				tspec := spec.(*ast.TypeSpec)
				if tspec.Name.Name != typeName {
					continue
				}
				styp, ok := tspec.Type.(*ast.StructType)
				if ok {
					stype = styp
					return false
				}
			}
			return true
		})
	}

	if stype == nil {
		log.Fatalf("not exist type %s", typeName)
	}

	g.Printf("// Code generated by \"accessor %s\"; DO NOT EDIT.\n\n", strings.Join(g.cmdArgs, " "))
	g.Printf("package %s\n", g.pkg.name)

	g.build(typeName, stype)

	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatalf("format source faild:%s", err)
	}
	g.buf.Reset()
	return src
}

const (
	getterFormat = `// %[2]s return %[3]s value
func (t %[1]s) %[2]s() %[4]s {
	return t.%[3]s
}
`
	setterFormat = `// Set%[2]s set v to %[3]s
func (t *%[1]s) Set%[2]s(v %[4]s) {
	t.%[3]s = v
}
`
)

func (g *generator) build(typeName string, typ *ast.StructType) {
	if typ.Fields.NumFields() == 0 {
		log.Fatal("struct has no field")
	}
	exist := false

	for _, field := range typ.Fields.List {
		// TODO: check field tag
		for _, name := range field.Names {
			if name.IsExported() {
				continue
			}
			typ := toTypeString(field.Type)
			if typ == "" {
				continue
			}

			// TODO: e.g.) url -> URL
			exportName := strings.ToUpper(string(name.Name[0])) + name.Name[1:]

			g.Printf(getterFormat, typeName, exportName, name.Name, typ)
			if g.withSetter {
				g.Printf(setterFormat, typeName, exportName, name.Name, typ)
			}
			exist = true
		}
	}

	if !exist {
		log.Fatal("struct don't have private field")
	}
}

// TODO: fix bad function
func toTypeString(exp ast.Expr) string {
	switch x := exp.(type) {
	case *ast.Ident:
		if x.Obj != nil {
			typs := x.Obj.Decl.(*ast.TypeSpec)
			if !typs.Name.IsExported() {
				return ""
			}
		}
	case *ast.StarExpr:
		if toTypeString(x.X) == "" {
			return ""
		}
	case *ast.ArrayType:
		if toTypeString(x.Elt) == "" {
			return ""
		}
	case *ast.MapType:
		if toTypeString(x.Key) == "" || toTypeString(x.Value) == "" {
			return ""
		}
	case *ast.FuncType:
		for _, f := range x.Params.List {
			if toTypeString(f.Type) == "" {
				return ""
			}
		}
		for _, f := range x.Results.List {
			if toTypeString(f.Type) == "" {
				return ""
			}
		}
	case *ast.StructType: // TODO: anonymous struct
		return ""
	case *ast.SelectorExpr:
	default:
		return ""
	}

	var buf bytes.Buffer
	if err := format.Node(&buf, token.NewFileSet(), exp); err != nil {
		log.Fatalf("format ast.Expr failed:%s", err)
	}

	return buf.String()
}
